package ceramic;

using StringTools;

// Some portions of this code taken from luxe (https://github.com/underscorediscovery/luxe/blob/4c891772f54b4769c72515146bedde9206a7b986/luxe/importers/bitmapfont/BitmapFontParser.hx)

/**
 * Parser for bitmap font definition files in BMFont format.
 *
 * BitmapFontParser reads and parses font definition files (.fnt) that describe
 * bitmap font layouts. It supports both plain text and XML formats commonly
 * generated by tools like:
 * - BMFont (AngelCode)
 * - Hiero
 * - msdf-bmfont-xml
 * - Construct 3 SpriteFont
 *
 * The parser extracts:
 * - Font metadata (face, size, line height)
 * - Character definitions with texture coordinates
 * - Texture page references
 * - Kerning pairs
 * - Distance field information (for MSDF fonts)
 *
 * ```haxe
 * // Parse a font definition file
 * var fontData = BitmapFontParser.parse(fontFileContent);
 *
 * // Create textures from the page files
 * var textures = new Map<String,Texture>();
 * for (page in fontData.pages) {
 *     textures.set(page.file, loadTexture(page.file));
 * }
 *
 * // Create the font
 * var font = new BitmapFont(fontData, textures);
 * ```
 *
 * @see BitmapFontData The data structure produced by parsing
 * @see BitmapFont The font class that uses parsed data
 */
class BitmapFontParser {

/// Public API

    /**
     * Parses a bitmap font definition file into structured data.
     *
     * Accepts plain text (.fnt), XML (.xml), and Construct 3 SpriteFont formats.
     * XML and Construct 3 formats are automatically detected and converted to
     * text format before parsing.
     *
     * @param rawFontData The raw content of the font definition file
     * @param imagePath Optional path to the font image file (required for Construct 3 format)
     * @param imageWidth Optional image width in pixels (required for Construct 3 format)
     * @return Parsed font data ready for use with BitmapFont
     * @throws String if the font data is invalid or empty
     */
    public static function parse(rawFontData:String, ?imagePath:String, ?imageWidth:Int):BitmapFontData {

        if (rawFontData.length == 0) {
            throw "BitmapFont: fontData is 0 length";
        }

        if (rawFontData.trim().startsWith('<')) {
            try {
                rawFontData = convertXmlFontData(rawFontData);
            }
            catch (e:Dynamic) {
                throw "BitmapFont: invalid xml font data specified for parser: " + e;
            }
        }
        var isConstruct3 = false;
        var originalRawFontData = rawFontData;

        if (rawFontData.indexOf('CONSTRUCT 3') != -1 && rawFontData.indexOf('Character width:') != -1) {
            isConstruct3 = true;
            try {
                rawFontData = convertConstruct3FontData(rawFontData, imagePath != null ? imagePath : 'font.png', imageWidth);
            }
            catch (e:Dynamic) {
                throw "BitmapFont: invalid Construct 3 font data specified for parser: " + e;
            }
        }

        var info:BitmapFontData = {
            path: '.',
            face: null,
            chars: new IntMap(),
            distanceField: null,
            pointSize: 0,
            baseSize: 0,
            charCount: 0,
            lineHeight: 0,
            pages: [],
            kernings: new IntMap(),
            smooth: true,
            aa: true,
            needsReparsing: false,
            rawFontData: null
        };

        // If it's a Construct 3 font without image width, mark for re-parsing
        if (isConstruct3 && imageWidth == null) {
            info.needsReparsing = true;
            info.rawFontData = originalRawFontData;
        }

        var lines:Array<String> = rawFontData.replace("\r", '').replace("\t", ' ').split("\n");

        if (lines.length == 0) {
            throw "BitmapFont: invalid font data specified for parser.";
        }

        var first = lines[0];
        if (StringTools.ltrim(first).substr(0, 4) != 'info') {
            throw "BitmapFont: invalid font data specified for parser. Format should be plain ascii text .fnt file only currently.";
        }

        for (line in lines) {
            parseLine(line, info);
        }

        lines = null;

        // Ensure space character exists
        ensureSpaceCharacter(info);

        return info;

    }

/// From XML

    /**
     * Converts XML format font data to plain text format.
     *
     * XML format is commonly used by tools like Hiero and msdf-bmfont-xml.
     * This method transforms the XML structure into the text-based format
     * that the parser expects internally.
     *
     * @param rawFontData XML font definition content
     * @return Equivalent font data in plain text format
     * @throws Dynamic if XML parsing fails
     */
    static function convertXmlFontData(rawFontData:String):String {

        var result = new StringBuf();

        inline function addValue(attr:String, value:String) {
            if (attr == 'face' || attr == 'char' || attr == 'file' || value.indexOf(' ') != -1 || value.indexOf('"') != -1 || value.indexOf('=') != -1) {
                result.add(haxe.Json.stringify(value));
            }
            else {
                result.add(value);
            }
        }

        inline function addElementAndAttributes(el:Xml) {
            result.add(el.nodeName);
            for (attr in el.attributes()) {
                var value = el.get(attr);
                if (value != null) {
                    result.add(' ');
                    result.add(attr);
                    result.add('=');
                    addValue(attr, value);
                }
            }
            result.add('\n');
        }

        var xml = Xml.parse(rawFontData).firstElement();

        for (el in xml.elements()) {
            switch el.nodeName {
                default:
                    addElementAndAttributes(el);
                case 'pages' | 'chars':
                    if (el.nodeName == 'chars') {
                        addElementAndAttributes(el);
                    }
                    for (subEl in el.elements()) {
                        addElementAndAttributes(subEl);
                    }
            }
        }

        return result.toString();

    }

/// From Construct 3

    /**
     * Converts Construct 3 SpriteFont format to plain text BMFont format.
     *
     * Construct 3 uses a different format that specifies:
     * - Character width and height (cell size in the grid)
     * - Character spacing (spacing when rendering text)
     * - Character set (all supported characters)
     * - Spacing data (width overrides for specific characters)
     *
     * In Construct 3, characters are laid out in a grid from left to right,
     * top to bottom, with no spacing between cells in the texture.
     *
     * @param rawFontData Construct 3 font definition content
     * @param imagePath Path to the font image file
     * @param imageWidth Width of the font texture in pixels (null for first-stage parsing)
     * @return Equivalent font data in BMFont plain text format
     * @throws Dynamic if parsing fails
     */
    static function convertConstruct3FontData(rawFontData:String, imagePath:String, ?imageWidth:Null<Int>):String {

        var result = new StringBuf();
        var lines = rawFontData.split('\n');

        var charWidth:Int = 0;
        var charHeight:Int = 0;
        var charSpacing:Int = 0;
        var charSet:String = '';
        var spacingData:Array<Array<Dynamic>> = [];

        var i = 0;
        while (i < lines.length) {
            var line = lines[i].trim();

            if (line.indexOf('Character width:') != -1) {
                charWidth = Std.parseInt(line.split(':')[1].trim());
            }
            else if (line.indexOf('Character height:') != -1) {
                charHeight = Std.parseInt(line.split(':')[1].trim());
            }
            else if (line.indexOf('Character spacing:') != -1) {
                charSpacing = Std.parseInt(line.split(':')[1].trim());
            }
            else if (line == 'Character set:') {
                // Character set might be on next line or the line after (if there's an empty line)
                i++;
                while (i < lines.length) {
                    var nextLine = lines[i].trim();
                    if (nextLine.length > 0) {
                        charSet = nextLine;
                        break;
                    }
                    i++;
                }
            }
            else if (line == 'Spacing data:') {
                i++;
                if (i < lines.length) {
                    var spacingLine = lines[i].trim();
                    try {
                        spacingData = haxe.Json.parse(spacingLine);
                    }
                    catch (e:Dynamic) {
                        spacingData = [];
                    }
                }
            }

            i++;
        }

        var charWidthMap = new Map<String, Int>();
        for (entry in spacingData) {
            if (entry.length >= 2) {
                var width = Std.int(entry[0]);
                var chars = Std.string(entry[1]);
                for (j in 0...chars.length) {
                    charWidthMap.set(chars.charAt(j), width);
                }
            }
        }

        // Calculate grid layout
        var charsPerRow:Int;
        var textureWidth:Int;
        var textureHeight:Int;

        if (imageWidth != null) {
            // We have the actual image width - calculate accurate layout
            charsPerRow = Math.floor(imageWidth / charWidth);
            if (charsPerRow == 0) charsPerRow = 1;

            var totalChars = charSet.length;
            var numRows = Math.ceil(totalChars / charsPerRow);

            textureWidth = imageWidth;
            textureHeight = numRows * charHeight;
        }
        else {
            // First-stage parsing - use placeholder values
            // These will be corrected in the second stage
            var totalChars = charSet.length;
            charsPerRow = Math.ceil(Math.sqrt(totalChars));
            var numRows = Math.ceil(totalChars / charsPerRow);

            textureWidth = charsPerRow * charWidth;
            textureHeight = numRows * charHeight;
        }

        result.add('info face="Construct3Font" size=');
        result.add(Std.string(charHeight));
        result.add(' bold=0 italic=0 charset="" unicode=1 stretchH=100 smooth=0 aa=0 padding=0,0,0,0 spacing=');
        result.add(Std.string(charSpacing));
        result.add(',');
        result.add(Std.string(charSpacing));
        result.add('\n');

        result.add('common lineHeight=');
        result.add(Std.string(charHeight + charSpacing));
        result.add(' base=');
        result.add(Std.string(charHeight));
        result.add(' scaleW=');
        result.add(Std.string(textureWidth));
        result.add(' scaleH=');
        result.add(Std.string(textureHeight));
        result.add(' pages=1 packed=0\n');

        result.add('page id=0 file="');
        result.add(imagePath);
        result.add('"\n');

        // Calculate total character count (including space if it's in spacing data)
        var totalCharCount = charSet.length;
        var spaceChar = ' ';
        if (!charSet.contains(spaceChar) && charWidthMap.exists(spaceChar)) {
            totalCharCount++;
        }

        result.add('chars count=');
        result.add(Std.string(totalCharCount));
        result.add('\n');

        for (i in 0...charSet.length) {
            var char = charSet.charAt(i);
            var charCode = charSet.charCodeAt(i);

            var actualWidth = charWidthMap.exists(char) ? charWidthMap.get(char) : charWidth;

            // Grid position (no spacing between cells in texture)
            var col = i % charsPerRow;
            var row = Math.floor(i / charsPerRow);
            var x = col * charWidth;
            var y = row * charHeight;

            result.add('char id=');
            result.add(Std.string(charCode));
            result.add(' x=');
            result.add(Std.string(x));
            result.add(' y=');
            result.add(Std.string(y));
            result.add(' width=');
            result.add(Std.string(actualWidth));
            result.add(' height=');
            result.add(Std.string(charHeight));
            result.add(' xoffset=0 yoffset=0 xadvance=');
            result.add(Std.string(actualWidth + charSpacing));
            result.add(' page=0\n');
        }

        // Check if space character is in the spacing data but not in the character set
        var spaceChar = ' ';
        if (!charSet.contains(spaceChar) && charWidthMap.exists(spaceChar)) {
            var spaceWidth = charWidthMap.get(spaceChar);
            var spaceCharCode = spaceChar.charCodeAt(0);

            // Add space character with no texture
            result.add('char id=');
            result.add(Std.string(spaceCharCode));
            result.add(' x=0 y=0 width=0 height=0'); // No texture needed
            result.add(' xoffset=0 yoffset=0 xadvance=');
            result.add(Std.string(spaceWidth + charSpacing));
            result.add(' page=0\n');
        }

        return result.toString();
    }

/// Internal

    /**
     * Parses a single line of font definition data.
     *
     * Each line starts with a token identifying the data type:
     * - `info`: Font face and size
     * - `common`: Line height and base size
     * - `page`: Texture page definition
     * - `chars`: Character count
     * - `char`: Individual character metrics
     * - `kerning`: Kerning pair data
     * - `distanceField`: MSDF configuration
     *
     * @param line A single line from the font file
     * @param info The font data structure to populate
     */
    static function parseLine(line:String, info:BitmapFontData) {

        var items = new Map();
        var firstToken = extractLineTokens(line, items);

        switch (firstToken) {

            case 'info': {
                info.face = unquote(items['face']);
                info.pointSize = Std.parseFloat(items['size']);

                if (items.exists('smooth')) {
                    info.smooth = items['smooth'] == '1' || items['smooth'] == 'true';
                }
                if (items.exists('aa')) {
                    info.aa = items['aa'] == '1' || items['aa'] == 'true';
                }
            }

            case 'common': {
                info.lineHeight = Std.parseFloat(items['lineHeight']);
                info.baseSize = Std.parseFloat(items['base']);
            }

            case 'page': {
                info.pages.push({
                    id: Std.parseInt(items['id']),
                    file: StringTools.trim(unquote(items['file']))
                });
            }

            case 'chars': {
                info.charCount = Std.parseInt(items["count"]);
            }

            case 'char': {

                var char: BitmapFontCharacter = {
                    id: Std.parseInt(items["id"]),
                    x: Std.parseFloat(items["x"]),
                    y: Std.parseFloat(items["y"]),
                    width: Std.parseFloat(items["width"]),
                    height: Std.parseFloat(items["height"]),
                    xOffset: Std.parseFloat(items["xoffset"]),
                    yOffset: Std.parseFloat(items["yoffset"]),
                    xAdvance: Std.parseFloat(items["xadvance"]),
                    page: Std.parseInt(items["page"])
                };

                info.chars.set(char.id, char);

            }

            case 'kerning': {

                var first = Std.parseInt(items["first"]);
                var second = Std.parseInt(items["second"]);
                var amount = Std.parseFloat(items["amount"]);

                var map = info.kernings.get(first);
                if (map == null) {
                    map = new IntFloatMap();
                    info.kernings.set(first, map);
                }

                map.set(second, amount);

            }

            case 'distanceField': {

                var fieldType = items["fieldType"];
                var distanceRange = Std.parseInt(items["distanceRange"]);

                info.distanceField = {
                    fieldType: fieldType,
                    distanceRange: distanceRange
                };

            }

            default:
        }

    }

    /**
     * Extracts key-value pairs from a font definition line.
     *
     * Parses lines in the format: `token key1=value1 key2="quoted value"`
     * Handles both quoted and unquoted values, with proper escape sequence support.
     *
     * @param line The line to parse
     * @param map Output map to populate with key-value pairs
     * @return The first token on the line (e.g., "char", "info")
     * @throws String if the line format is invalid
     */
    static function extractLineTokens(line:String, map:Map<String,String>):String {

        var i = 0;
        var len = line.length;
        var firstToken:String = null;
        var keyToken:String = null;
        var nextToken:StringBuf = null;
        var inQuotes = false;

        while (i < len) {

            var c = line.charCodeAt(i);

            if (inQuotes) {
                if (c == '\\'.code) {
                    c = line.charCodeAt(i);
                    i++;
                }
                else if (c == '"'.code) {
                    inQuotes = false;
                }
                if (nextToken == null) {
                    throw 'Invalid bitmap font line: $line';
                }
                nextToken.add(line.charAt(i));
            }
            else if (c == ' '.code) {
                if (nextToken != null) {
                    if (firstToken == null) {
                        firstToken = nextToken.toString();
                    }
                    else if (keyToken == null) {
                        keyToken = nextToken.toString();
                        map.set(keyToken, null);
                    }
                    else {
                        map.set(keyToken, nextToken.toString());
                    }
                    keyToken = null;
                    nextToken = null;
                }
            }
            else if (keyToken == null && c == '='.code) {
                if (nextToken == null) {
                    throw 'Invalid bitmap font line: $line';
                }
                keyToken = nextToken.toString();
                nextToken = null;
            }
            else {
                if (c == '"'.code) {
                    inQuotes = true;
                }
                if (nextToken == null) {
                    nextToken = new StringBuf();
                }
                nextToken.add(line.charAt(i));
            }

            i++;

        }

        if (nextToken != null) {
            if (firstToken == null) {
                firstToken = nextToken.toString();
            }
            else if (keyToken == null) {
                keyToken = nextToken.toString();
                map.set(keyToken, null);
            }
            else {
                map.set(keyToken, nextToken.toString());
            }
            keyToken = null;
            nextToken = null;
        }

        return firstToken;

    }

    /**
     * Removes surrounding quotes from a string if present.
     *
     * Used to clean up quoted values from the font file.
     * Only removes quotes if they exist at both start and end.
     *
     * @param s The string to unquote
     * @return The string without surrounding quotes
     */
    inline static function unquote(s:String) {

        var len = s.length;

        if (s.charCodeAt(0) == '"'.code && s.charCodeAt(len - 1) == '"'.code) {
            s = s.substring(1, len - 1);
        }

        return s;

    }

    /**
     * Ensures a space character exists in the font data.
     * If missing, creates one based on common character widths.
     *
     * The space character uses:
     * - For monospace fonts: same advance as other characters
     * - For proportional fonts: ~40-50% of average character width
     * - Zero texture dimensions (no rendering needed)
     *
     * @param info The font data to check and modify
     */
    static function ensureSpaceCharacter(info:BitmapFontData):Void {

        var spaceCharCode = ' '.code; // 32

        // Check if space character already exists
        if (info.chars.exists(spaceCharCode)) {
            return;
        }

        // First, detect if this is a monospace font
        // Check if all characters have the same xAdvance
        var isMonospace = true;
        var firstAdvance:Float = -1;

        for (char in info.chars) {
            if (firstAdvance < 0) {
                firstAdvance = char.xAdvance;
            }
            else if (char.xAdvance != firstAdvance) {
                isMonospace = false;
                break;
            }
        }

        // Calculate appropriate width for space character
        var spaceWidth:Float = 0;

        if (isMonospace && firstAdvance > 0) {
            // For monospace fonts, use the common advance
            spaceWidth = firstAdvance;
        }
        else {
            // For proportional fonts, calculate based on common characters
            var referenceChars = ['n'.code, 'e'.code, 'o'.code, 'a'.code, 'r'.code];
            var foundCount = 0;

            // Try to use common lowercase letters as reference
            for (charCode in referenceChars) {
                if (info.chars.exists(charCode)) {
                    var char = info.chars.get(charCode);
                    spaceWidth += char.xAdvance;
                    foundCount++;
                }
            }

            if (foundCount > 0) {
                // Use ~40% of average of found characters for proportional fonts
                spaceWidth = (spaceWidth / foundCount) * 0.4;
            }
            else {
                // Fallback: use average of all characters
                var totalWidth:Float = 0;
                var charCount = 0;
                for (char in info.chars) {
                    totalWidth += char.xAdvance;
                    charCount++;
                }
                if (charCount > 0) {
                    // Use ~40% of average for proportional fonts
                    spaceWidth = (totalWidth / charCount) * 0.4;
                }
                else {
                    // Last resort: use baseSize / 3
                    spaceWidth = info.baseSize / 3;
                }
            }
        }

        // Create space character with no texture (width/height = 0)
        var spaceChar:BitmapFontCharacter = {
            id: spaceCharCode,
            x: 0,
            y: 0,
            width: 0,  // No texture needed
            height: 0, // No texture needed
            xOffset: 0,
            yOffset: 0,
            xAdvance: spaceWidth,
            page: 0
        };

        info.chars.set(spaceCharCode, spaceChar);
    }

}
