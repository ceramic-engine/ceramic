package backend;

import ceramic.Path;
import clay.Clay;
import clay.buffers.Uint8Array;

using StringTools;

/**
 * Clay backend implementation of shader program management.
 * Handles loading GLSL shaders from files and multi-texture batching.
 *
 * This class loads shader files generated by the shade compiler:
 * - Standard shaders: basename.vert, basename.frag
 * - Multi-texture variants: basename_mt8.vert, basename_mt8.frag
 *
 * @see ceramic.Shader
 * @see backend.ShaderImpl
 */
class Shaders implements spec.Shaders {

    public function new() {}

    /**
     * Loads a shader from .vert and .frag files.
     * Automatically attempts to load multi-texture variant (_mt8 suffix) first for better batching performance.
     *
     * @param path Path to the shader (without extension, e.g., "shaders/default")
     * @param baseAttributes Base vertex attributes (position, texCoord, color)
     * @param customAttributes Custom vertex attributes beyond base ones (can be null)
     * @param textureIdAttribute Texture slot attribute for multi-texture batching (can be null)
     * @param _done Callback with loaded shader (null on failure)
     */
    public function load(path:String, baseAttributes:ceramic.ReadOnlyArray<ceramic.ShaderAttribute>, customAttributes:ceramic.ReadOnlyArray<ceramic.ShaderAttribute>, textureIdAttribute:ceramic.ShaderAttribute, _done:(shader:backend.Shader)->Void):Void {

        var done = function(shader:Shader) {
            ceramic.App.app.onceImmediate(function() {
                _done(shader);
                _done = null;
            });
        };


        var isUrl:Bool = path.startsWith('http://') || path.startsWith('https://');
        path = Path.isAbsolute(path) || isUrl ?
            path
        :
            Path.join([ceramic.App.app.settings.assetsPath, path]);
        var basePath = Path.withoutExtension(path);

        #if !ceramic_no_multitexture
        if (textureIdAttribute != null) {
            // Try multi-texture variant first
            var pathMt8 = basePath + '_mt8';
            tryLoadShader(pathMt8, baseAttributes, customAttributes, textureIdAttribute, true, function(shader) {
                if (shader != null) {
                    shader.isBatchingMultiTexture = true;
                    done(shader);
                } else {
                    // Fallback to regular shader
                    tryLoadShader(basePath, baseAttributes, customAttributes, textureIdAttribute, false, function(shader) {
                        if (shader != null) {
                            shader.isBatchingMultiTexture = false;
                        }
                        done(shader);
                    });
                }
            });
        } else {
            // No texture ID attribute, skip multi-texture variant
            tryLoadShader(basePath, baseAttributes, customAttributes, textureIdAttribute, false, function(shader) {
                if (shader != null) {
                    shader.isBatchingMultiTexture = false;
                }
                done(shader);
            });
        }
        #else
        tryLoadShader(basePath, baseAttributes, customAttributes, textureIdAttribute, false, function(shader) {
            if (shader != null) {
                shader.isBatchingMultiTexture = false;
            }
            done(shader);
        });
        #end

    }

    /**
     * Attempts to load a shader from the given base path.
     * Reads .vert and .frag files asynchronously and compiles them.
     * @param basePath Path without extension
     * @param baseAttributes Base vertex attributes
     * @param customAttributes Custom vertex attributes
     * @param textureIdAttribute Texture slot attribute for multi-texture
     * @param isMultiTexture Whether this is a multi-texture variant
     * @param callback Called with shader or null on failure
     */
    function tryLoadShader(basePath:String, baseAttributes:ceramic.ReadOnlyArray<ceramic.ShaderAttribute>, customAttributes:ceramic.ReadOnlyArray<ceramic.ShaderAttribute>, textureIdAttribute:ceramic.ShaderAttribute, isMultiTexture:Bool, callback:ShaderImpl->Void):Void {
        var vertPath = basePath + '.vert';
        var fragPath = basePath + '.frag';

        // Resolve full paths
        var fullVertPath = Clay.app.assets.fullPath(vertPath);
        var fullFragPath = Clay.app.assets.fullPath(fragPath);

        // Load vertex shader first
        Clay.app.io.loadData(fullVertPath, true, true, function(vertData:Uint8Array) {
            if (vertData == null) {
                callback(null);
                return;
            }

            var vertSource = vertData.toBytes().toString();

            // Load fragment shader
            Clay.app.io.loadData(fullFragPath, true, true, function(fragData:Uint8Array) {
                if (fragData == null) {
                    callback(null);
                    return;
                }

                var fragSource = fragData.toBytes().toString();

                // Build attributes list from parameters
                var attrs:Array<String> = [];

                // Add base attributes
                if (baseAttributes != null) {
                    for (i in 0...baseAttributes.length) {
                        attrs.push(baseAttributes[i].name);
                    }
                }

                // Add texture slot attribute for multi-texture variants
                if (isMultiTexture && textureIdAttribute != null) {
                    attrs.push(textureIdAttribute.name);
                }

                // Add custom attribute names
                if (customAttributes != null) {
                    for (i in 0...customAttributes.length) {
                        attrs.push(customAttributes[i].name);
                    }
                }

                // Create shader from source
                var shader = new ShaderImpl();
                shader.attributes = attrs;
                shader.textures = isMultiTexture ? buildMultiTextures() : ['mainTex'];
                shader.vertSource = vertSource;
                shader.fragSource = fragSource;
                shader.customAttributes = customAttributes;

                try {
                    shader.init();
                    callback(shader);
                } catch (e:Dynamic) {
                    callback(null);
                }
            });
        });
    }

    /**
     * Builds texture uniform names array for multi-texture batching.
     * @return Array of texture uniform names (mainTex, tex1, ..., tex8)
     */
    function buildMultiTextures():Array<String> {
        var textures = ['mainTex'];
        for (i in 1...9) {
            textures.push('tex$i');
        }
        return textures;
    }

    /**
     * Destroys a shader program and releases GPU resources.
     * @param shader The shader to destroy
     */
    inline public function destroy(shader:Shader):Void {

        (shader:ShaderImpl).destroy();

    }

    /**
     * Creates a deep copy of a shader program.
     * @param shader The shader to clone
     * @return A new shader instance with the same properties
     */
    inline public function clone(shader:Shader):Shader {

        return (shader:ShaderImpl).clone();

    }

/// Public API

    /**
     * Sets an integer uniform value in the shader.
     * @param shader Target shader program
     * @param name Uniform variable name
     * @param value Integer value to set
     */
    inline public function setInt(shader:Shader, name:String, value:Int):Void {

        (shader:ShaderImpl).uniforms.setInt(name, value);

    }

    /**
     * Sets a float uniform value in the shader.
     * @param shader Target shader program
     * @param name Uniform variable name
     * @param value Float value to set
     */
    inline public function setFloat(shader:Shader, name:String, value:Float):Void {

        (shader:ShaderImpl).uniforms.setFloat(name, value);

    }

    /**
     * Sets a 2D vector uniform value in the shader.
     * @param shader Target shader program
     * @param name Uniform variable name
     * @param x X component
     * @param y Y component
     */
    inline public function setVec2(shader:Shader, name:String, x:Float, y:Float):Void {

        (shader:ShaderImpl).uniforms.setVector2(name, x, y);

    }

    /**
     * Sets a 3D vector uniform value in the shader.
     * @param shader Target shader program
     * @param name Uniform variable name
     * @param x X component
     * @param y Y component
     * @param z Z component
     */
    inline public function setVec3(shader:Shader, name:String, x:Float, y:Float, z:Float):Void {

        (shader:ShaderImpl).uniforms.setVector3(name, x, y, z);

    }

    /**
     * Sets a 4D vector uniform value in the shader.
     * @param shader Target shader program
     * @param name Uniform variable name
     * @param x X component
     * @param y Y component
     * @param z Z component
     * @param w W component
     */
    inline public function setVec4(shader:Shader, name:String, x:Float, y:Float, z:Float, w:Float):Void {

        (shader:ShaderImpl).uniforms.setVector4(name, x, y, z, w);

    }

    /**
     * Sets a float array uniform value in the shader.
     * @param shader Target shader program
     * @param name Uniform variable name
     * @param array Array of float values
     */
    inline public function setFloatArray(shader:Shader, name:String, array:Array<Float>):Void {

        (shader:ShaderImpl).uniforms.setFloatArray(name, Float32Array.fromArray(array));

    }

    /**
     * Sets a texture uniform value in the shader.
     * @param shader Target shader program
     * @param name Uniform variable name
     * @param slot Texture unit slot (0-based)
     * @param texture Texture to bind
     */
    inline public function setTexture(shader:Shader, name:String, slot:Int, texture:backend.Texture):Void {

        (shader:ShaderImpl).uniforms.setTexture(name, slot, texture);

    }

    /**
     * Sets a 2x2 matrix uniform value in the shader (column-major order).
     * @param shader Target shader program
     * @param name Uniform variable name
     * @param m00 Column 0, row 0
     * @param m10 Column 0, row 1
     * @param m01 Column 1, row 0
     * @param m11 Column 1, row 1
     */
    inline public function setMat2(shader:Shader, name:String, m00:Float, m10:Float, m01:Float, m11:Float):Void {

        (shader:ShaderImpl).uniforms.setMatrix2(name, Float32Array.fromArray([m00, m10, m01, m11]));

    }

    /**
     * Sets a 3x3 matrix uniform value in the shader (column-major order).
     * @param shader Target shader program
     * @param name Uniform variable name
     * @param m00 Column 0, row 0
     * @param m10 Column 0, row 1
     * @param m20 Column 0, row 2
     * @param m01 Column 1, row 0
     * @param m11 Column 1, row 1
     * @param m21 Column 1, row 2
     * @param m02 Column 2, row 0
     * @param m12 Column 2, row 1
     * @param m22 Column 2, row 2
     */
    inline public function setMat3(shader:Shader, name:String, m00:Float, m10:Float, m20:Float, m01:Float, m11:Float, m21:Float, m02:Float, m12:Float, m22:Float):Void {

        (shader:ShaderImpl).uniforms.setMatrix3(name, Float32Array.fromArray([m00, m10, m20, m01, m11, m21, m02, m12, m22]));

    }

    /**
     * Sets a 4x4 matrix uniform value in the shader (column-major order).
     * @param shader Target shader program
     * @param name Uniform variable name
     * @param m00 Column 0, row 0
     * @param m10 Column 0, row 1
     * @param m20 Column 0, row 2
     * @param m30 Column 0, row 3
     * @param m01 Column 1, row 0
     * @param m11 Column 1, row 1
     * @param m21 Column 1, row 2
     * @param m31 Column 1, row 3
     * @param m02 Column 2, row 0
     * @param m12 Column 2, row 1
     * @param m22 Column 2, row 2
     * @param m32 Column 2, row 3
     * @param m03 Column 3, row 0
     * @param m13 Column 3, row 1
     * @param m23 Column 3, row 2
     * @param m33 Column 3, row 3
     */
    inline public function setMat4(shader:Shader, name:String, m00:Float, m10:Float, m20:Float, m30:Float, m01:Float, m11:Float, m21:Float, m31:Float, m02:Float, m12:Float, m22:Float, m32:Float, m03:Float, m13:Float, m23:Float, m33:Float):Void {

        (shader:ShaderImpl).uniforms.setMatrix4(name, Float32Array.fromArray([m00, m10, m20, m30, m01, m11, m21, m31, m02, m12, m22, m32, m03, m13, m23, m33]));

    }

    /**
     * Calculates the total size of custom float attributes for a shader.
     * Used for vertex buffer layout calculations.
     *
     * @param shader The shader to analyze
     * @return Total number of floats needed for custom attributes
     */
    inline public function customFloatAttributesSize(shader:ShaderImpl):Int {

        var customFloatAttributesSize = 0;

        var allAttrs = shader.customAttributes;
        if (allAttrs != null) {
            for (ii in 0...allAttrs.length) {
                var attr = allAttrs.unsafeGet(ii);
                customFloatAttributesSize += attr.size;
            }
        }

        return customFloatAttributesSize;

    }

    /**
     * Returns the maximum number of if-statements supported by fragment shaders.
     * For shaders with _mt8 variants, this is always 8.
     *
     * @return Maximum if-statements supported (8 for multi-texture shaders)
     */
    public function maxIfStatementsByFragmentShader():Int {
        return 8;
    }

    /**
     * Checks if a shader supports multi-texture batching.
     * Multi-texture shaders can render multiple textures in a single draw call.
     *
     * @param shader The shader to check
     * @return True if the shader supports multi-texture batching
     */
    public function canBatchWithMultipleTextures(shader:Shader):Bool {

        return (shader:ShaderImpl).isBatchingMultiTexture;

    }

    /**
     * Indicates whether hot-reloading of shader files is supported.
     * Clay backend supports watching shader files for changes.
     *
     * @return Always returns true for Clay backend
     */
    inline public function supportsHotReloadPath():Bool {

        return true;

    }

}
